package com.atball.der.search.jvm;

public class JvmLearning {

    // JVM性能调优
    /**
     *  JVM内存结构
     *  类加载机制和JDK的调优工具命令
     *  GC日志格式
     *  GC调优实战
     */

    // JVM的基本结构
    /**
     * JVM由三个主要的子系统构成
     *      类加载子系统  javac 命名编译文件  javap -c xxx.class > xxx.txt
     *      运行时数据区（内存结构）{堆、栈、本地方法栈、方法区、程序计数器}
     *             堆和方法区是线程共享的
     *             栈、本地方法栈、程序计数器是线程私有，随着线程创建而存在，线程销毁而消失
     *
     *      执行引擎：
     *      本地方法栈：存放native方法的地方
     *      方法区：常量池，class文件 堆外内存
     *
     *
     *
     */


    // 线程
    /**
     * 程序计数器，本地方法栈、栈（栈帧{操作数栈，局部变量表、动态链接、方法出口,}  ）
     * 程序计数器: 指针（指向下一个需要运行的字节码指令地址）
     * 栈: java执行方法时的内存模型 一个线程对应一个栈
     * 局部变量表：存放方法执行时的局部变量
     * 方法出口：指向调用者的地址 方法结束（分为正常退出或者异常退出）（栈帧返回值需要返回的地址）
     * 动态链接：
     *
     */
    // 类的生命周期
    /**
     * 加载（将.class文件从磁盘读到内存）、验证（验证字节码文件的正确性）、准备（给静态变量分配内存，并赋予默认值）
     * 、解析、初始化、使用、卸载
     */
    // 类加载器
    /**
     * 启动类加载器
     * bootstrapClassLoader
     *
     * 扩展类加载器
     * extensionClassLoader
     *
     * ApplicationClassLoader
     * 系统类加载器
     *
     * customClassLoader
     * 用户 自定义加载器
     *
     *
     * 类加载机制
     *      双亲委派机制：类加载先向上委托，在向下
     *         优点：沙箱安全机制: 比如自己写的String.class类不会被加载，这样可以防止核心库被随意篡改
     *              避免类的重复加载：当父ClassLoader已经被加载了该类的时候，就不要子加载器再加载一次
     *
     *      打破双亲委派机制
     */
}

